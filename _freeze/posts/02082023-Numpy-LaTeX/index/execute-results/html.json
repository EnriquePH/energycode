{
  "hash": "66ad721dde1fa285433938735f051d10",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Convert a NumPy array to LaTeX\ndescription: LaTeX matrices and determinants from NumPy arrays\nauthor: 'Enrique Pérez Herrero'\ndate: '08-02-2023'\neditor: source\nimage: 'theta3x3matrix.png'\ndraft: false\ncategories:\n  - python\n  - numpy\n  - latex\n---\n\n\n![Sierra de las Nieves (Málaga)](20180104_134329.jpg)\n\n# Convert Numpy array to $LaTeX$\n\nSometimes, when you are writing a statistics or a math article, you must go\nthrough a tedious process of typing and testing numerous lines of text until\nyour  code works. This can be especially boring when dealing with long matrices.\nIf you want to improve your productivity, automating this process comes in very\nhandy, and [Python](https://www.python.org/) is particularly useful for that.\n\n\n## Functions for matrices and determinants\n\nThe functions `matrix2latex` and `det2latex` generate an indented $LaTeX$ string\nthat can be copied or directly rendered in your math article.\n\nThe  `INDENT_SPACES` parameter specifies the number of spaces used for\nindentation.\n\n::: {#latex_functions .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\nINDENT_SPACES = 3\n\ndef indent(num_indent=1):\n    \"\"\"\n    Number of spaces for indentation\n    \"\"\"\n    return num_indent * INDENT_SPACES * \" \"\n\ndef matrix2latex(matrix):\n    \"\"\"\n    Convert a NumPy array to LaTeX code as a matrix\n    \"\"\"\n    left_latex = r\"\\left(\" + \"\\n\" + indent(1) + r\"\\begin{array}\"\n    right_latex = indent(1) + r\"\\end{array}\" + \"\\n\" + r\"\\right)\"\n    m_cols = matrix.shape[1]\n    array_cols = \"{\" + \"r\" * m_cols + \"}\\n\"\n    elements_latex = \"\"\n    for row in matrix:\n        elements_latex = \\\n          elements_latex + indent(2) + \" & \".join([str(x) for x in row]) + \\\n            r\" \\\\ \" + \"\\n\"\n    latex = left_latex + array_cols + elements_latex + right_latex\n    return f\"$$\\n{latex}\\n$$\"\n\ndef det2latex(matrix):\n    \"\"\"\n    Convert a NumPy array to LaTeX code as a determinant\n    \"\"\"\n    left_latex = r\"\\begin{vmatrix}\" + \"\\n\"\n    right_latex = r\"\\end{vmatrix}\"\n    m_cols = matrix.shape[1]\n    elements_latex = \"\"\n    for row in matrix:\n        elements_latex = \\\n          elements_latex + indent(1) + \" & \".join([str(x) for x in row]) + \\\n            r\" \\\\ \" + \"\\n\"\n    latex = left_latex + elements_latex + right_latex\n    return f\"$$\\n{latex}\\n$$\"\n```\n:::\n\n\n### Output string\n\nUsing the [NumPy](https://numpy.org/) function `np.eye`, we can create an\nidentity matrix of the desired dimensions, making it a convenient tool for\ntesting our functions.\n\n::: {#5375725c .cell execution_count=2}\n``` {.python .cell-code}\nprint(matrix2latex(np.eye(3, dtype=int)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$$\n\\left(\n   \\begin{array}{rrr}\n      1 & 0 & 0 \\\\ \n      0 & 1 & 0 \\\\ \n      0 & 0 & 1 \\\\ \n   \\end{array}\n\\right)\n$$\n```\n:::\n:::\n\n\n## Rendering output in a document\n\nIf you are working in a [Jupyter](https://jupyter.org/) notebook, you can render\na $LaTeX$ string using the `Math` function from the `IPython` library, which can\nbe imported as follows:\n\n::: {#703f6382 .cell execution_count=3}\n``` {.python .cell-code}\nfrom IPython.display import Math\n```\n:::\n\n\nIf you are writing a `Python` chunk in a `Quarto` file in\n[RStudio](https://posit.co/download/rstudio-desktop/), you need to include the\noption `#| output: asis` at the top of the code chunk. This option determines\nhow the output is rendered in the final document.\n\n::: {#identity_det .cell execution_count=4}\n``` {.python .cell-code}\nprint(det2latex(np.eye(3, dtype=int)))\n```\n$$\n\\begin{vmatrix}\n   1 & 0 & 0 \\\\ \n   0 & 1 & 0 \\\\ \n   0 & 0 & 1 \\\\ \n\\end{vmatrix}\n$$\n:::\n\n\n::: {#identity_matrix .cell execution_count=5}\n``` {.python .cell-code}\n# Identity 4x4 matrix\nidentity_4 = np.eye(4, dtype=int)\nidentity_4_latex = r\"$$I_4 = \" + f\"{matrix2latex(identity_4)}\"[2:]\nprint(identity_4_latex)\n```\n$$I_4 = \n\\left(\n   \\begin{array}{rrrr}\n      1 & 0 & 0 & 0 \\\\ \n      0 & 1 & 0 & 0 \\\\ \n      0 & 0 & 1 & 0 \\\\ \n      0 & 0 & 0 & 1 \\\\ \n   \\end{array}\n\\right)\n$$\n:::\n\n\n## Rendering the output to a file\n\nThe $LaTeX$ string can be rendered and saved to a file using the\nfollowing function, which is based on the `SymPy` library.\n\n::: {#e4070aed .cell execution_count=6}\n``` {.python .cell-code}\nfrom sympy import preview\n\ndef latex2png(latex, filename, fontsize=300):\n    \"\"\"\n    Render LaTeX code to a PNG image\n    \"\"\"\n    return preview(latex,\n                   viewer='file',\n                   filename=filename,\n                   euler=False,\n                   dvioptions=['-D', f'{str(fontsize)}'])\n```\n:::\n\n\n## Other types of automated matrices\n\n### Matrices with numbered elements\n\n::: {#d947b8ce .cell execution_count=7}\n``` {.python .cell-code}\ndef element_matrix(n, notation=r\"x\"):\n    \"\"\"\n    Matrix with elements in algebraic notation \n    \"\"\"\n    vec_function = \\\n      np.vectorize(lambda i, j: notation + \"_{\" + f\"{i + 1}{j + 1}\" + \"}\")\n    return np.fromfunction(vec_function,\n                           shape=(n, n),\n                           dtype=int)\n```\n:::\n\n\n::: {#element_matrix_example .cell execution_count=8}\n``` {.python .cell-code}\nprint(matrix2latex(element_matrix(5, notation=r\"\\theta\")))\n```\n$$\n\\left(\n   \\begin{array}{rrrrr}\n      \\theta_{11} & \\theta_{12} & \\theta_{13} & \\theta_{14} & \\theta_{15} \\\\ \n      \\theta_{21} & \\theta_{22} & \\theta_{23} & \\theta_{24} & \\theta_{25} \\\\ \n      \\theta_{31} & \\theta_{32} & \\theta_{33} & \\theta_{34} & \\theta_{35} \\\\ \n      \\theta_{41} & \\theta_{42} & \\theta_{43} & \\theta_{44} & \\theta_{45} \\\\ \n      \\theta_{51} & \\theta_{52} & \\theta_{53} & \\theta_{54} & \\theta_{55} \\\\ \n   \\end{array}\n\\right)\n$$\n:::\n\n\n### Triangular matrices\n\n* _Upper Triangular Matrix_: In an upper triangular matrix, all elements below the\nmain diagonal are zero.\n\n::: {#30e397e1 .cell execution_count=9}\n``` {.python .cell-code}\ndef up_triangular_matrix(n):\n    \"\"\"\n    Upper Triangular matrix filled with ones and zeros\n    \"\"\"\n    return np.fromfunction(lambda i, j:  1 * np.less_equal(i , j),\n                           shape=(n, n),\n                           dtype=int)\n```\n:::\n\n\n* _Lower Triangular Matrix_: In a lower triangular matrix, all elements above the main diagonal are zero.\n\n::: {#1d8d1b0f .cell execution_count=10}\n``` {.python .cell-code}\ndef lw_triangular_matrix(n):\n    \"\"\"\n    Lower Triangular matrix filled with ones and zeros\n    \"\"\"\n    return np.fromfunction(lambda i, j:  1 * np.greater_equal(i , j),\n                           shape=(n, n),\n                           dtype=int)\n```\n:::\n\n\n::: {#upper_matrix_example .cell execution_count=11}\n``` {.python .cell-code}\nprint(matrix2latex(up_triangular_matrix(5)))\n```\n$$\n\\left(\n   \\begin{array}{rrrrr}\n      1 & 1 & 1 & 1 & 1 \\\\ \n      0 & 1 & 1 & 1 & 1 \\\\ \n      0 & 0 & 1 & 1 & 1 \\\\ \n      0 & 0 & 0 & 1 & 1 \\\\ \n      0 & 0 & 0 & 0 & 1 \\\\ \n   \\end{array}\n\\right)\n$$\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}