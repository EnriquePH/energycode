{
  "hash": "17a6ec4d90ad45ba4bd7ba13b5cb4a7b",
  "result": {
    "markdown": "---\ntitle: Convert Numpy array to LaTeX\ndescription: LaTeX matrices and determinants from numpy arrays\nauthor: 'Enrique Pérez Herrero'\ndate: '08-02-2023'\neditor: source\nimage: 'theta3x3matrix.png'\ndraft: false\ncategories:\n  - python\n  - numpy\n  - latex\n---\n\n![Sierra de las Nieves (Málaga)](20180104_134329.jpg)\n\n# Convert Numpy array to $LaTeX$\n\nSometimes, when you are writing a statistics or a math article, you must go\nthrough a tedious process of typing and testing numerous lines of text until\nyour $LaTeX$ code works. This can be especially boring when dealing with long\nmatrices. If you want to improve your productivity, automating this process\ncomes in very handy, and Python is particularly useful for that.\n\n\n## Functions for matrices and determinants\n\nThe functions `matrix2latex` and `det2latex` return an indented $LaTeX$ string\nthat can be copied or rendered in your math article.\n\nThe parameter `INDENT_SPACES` controls the number of indentation spaces.\n\n::: {#latex_functions .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\nINDENT_SPACES = 3\n\ndef indent(num_indent=1):\n    \"\"\"\n    Number of indentation spaces\n    \"\"\"\n    return num_indent * INDENT_SPACES * \" \"\n\n\ndef matrix2latex(matrix):\n    \"\"\"\n    Convert numpy array to latex code as a matrix\n    \"\"\"\n    left_latex = r\"\\left(\" + \"\\n\" + indent(1) + r\"\\begin{array}\"\n    right_latex = indent(1) + r\"\\end{array}\" + \"\\n\" + r\"\\right)\"\n    m_cols = matrix.shape[1]\n    array_cols = \"{\" + \"r\" * m_cols + \"}\\n\"\n    elements_latex = \"\"\n    for row in matrix:\n        elements_latex = \\\n          elements_latex + indent(2) + \" & \".join([str(x) for x in row]) + \\\n            r\" \\\\ \" + \"\\n\"\n    latex = left_latex + array_cols + elements_latex + right_latex\n    return f\"$$\\n{latex}\\n$$\"\n\n\ndef det2latex(matrix):\n    \"\"\"\n    Convert numpy array to latex code as a determinant\n    \"\"\"\n    left_latex = r\"\\begin{vmatrix}\" + \"\\n\"\n    right_latex = r\"\\end{vmatrix}\"\n    m_cols = matrix.shape[1]\n    elements_latex = \"\"\n    for row in matrix:\n        elements_latex = \\\n          elements_latex + indent(1) + \" & \".join([str(x) for x in row]) + \\\n            r\" \\\\ \" + \"\\n\"\n    latex = left_latex + elements_latex + right_latex\n    return f\"$$\\n{latex}\\n$$\"\n```\n:::\n\n\n### Output string\n\nWith the NumPy function `np.eye`, we can create an identity matrix of the\ndesired dimensions, and this seems to be a good way to test our functions.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nprint(matrix2latex(np.eye(3, dtype=int)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$$\n\\left(\n   \\begin{array}{rrr}\n      1 & 0 & 0 \\\\ \n      0 & 1 & 0 \\\\ \n      0 & 0 & 1 \\\\ \n   \\end{array}\n\\right)\n$$\n```\n:::\n:::\n\n\n## Rendering the output in a document\n\nIf you are working within a [Jupyter](https://jupyter.org/) notebook you can\nrender a latex string with the aid of the `Math` function included in the\n`IPython` library, which can be imported with:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nfrom IPython.display import Math\n```\n:::\n\n\nBut if you are coding a `Python` chunk in a `Quarto` file on RStudio, you need\nto add the option `#| output: asis` at the top of the code chunk. This option\ncontrols how the output is rendered in the final document.\n\n``` {.python .cell-code}\nprint(det2latex(np.eye(3, dtype=int)))\n```\n$$\n\\begin{vmatrix}\n   1 & 0 & 0 \\\\ \n   0 & 1 & 0 \\\\ \n   0 & 0 & 1 \\\\ \n\\end{vmatrix}\n$$\n\n\n``` {.python .cell-code}\n# Identity 4x4 matrix\nidentity_4 = np.eye(4, dtype=int)\nidentity_4_latex = r\"$$I_4 = \" + f\"{matrix2latex(identity_4)}\"[2:]\nprint(identity_4_latex)\n```\n$$I_4 = \n\\left(\n   \\begin{array}{rrrr}\n      1 & 0 & 0 & 0 \\\\ \n      0 & 1 & 0 & 0 \\\\ \n      0 & 0 & 1 & 0 \\\\ \n      0 & 0 & 0 & 1 \\\\ \n   \\end{array}\n\\right)\n$$\n\n\n## Rendering the output in a file\n\nThe $LaTeX$ string can be rendered and saved into a file with the aid of the\nfollowing function, based on the library `sympy`.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nfrom sympy import preview\n\ndef latex2png(latex, filename, fontsize=300):\n    \"\"\"\n    Render latex code to png image\n    \"\"\"\n    return preview(latex,\n                   viewer='file',\n                   filename=filename,\n                   euler=False,\n                   dvioptions=['-D', f'{str(fontsize)}'])\n```\n:::\n\n\n## Other automated matrices\n\n### Matrices with numbered elements\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef element_matrix(n, notation=r\"x\"):\n    \"\"\"\n    Matrix with algebraic notation elements \n    \"\"\"\n    vec_function = \\\n      np.vectorize(lambda i, j: notation + \"_{\" + f\"{i + 1}{j + 1}\" + \"}\")\n    return np.fromfunction(vec_function,\n                           shape=(n, n),\n                           dtype=int)\n```\n:::\n\n\n``` {.python .cell-code}\nprint(matrix2latex(element_matrix(5, notation=r\"\\theta\")))\n```\n$$\n\\left(\n   \\begin{array}{rrrrr}\n      \\theta_{11} & \\theta_{12} & \\theta_{13} & \\theta_{14} & \\theta_{15} \\\\ \n      \\theta_{21} & \\theta_{22} & \\theta_{23} & \\theta_{24} & \\theta_{25} \\\\ \n      \\theta_{31} & \\theta_{32} & \\theta_{33} & \\theta_{34} & \\theta_{35} \\\\ \n      \\theta_{41} & \\theta_{42} & \\theta_{43} & \\theta_{44} & \\theta_{45} \\\\ \n      \\theta_{51} & \\theta_{52} & \\theta_{53} & \\theta_{54} & \\theta_{55} \\\\ \n   \\end{array}\n\\right)\n$$\n\n\n### Triangular matrices\n\n* Upper Triangular Matrix: In an upper triangular matrix, all elements below the\nmain diagonal (elements that lie on or below the main diagonal) are zeros.\n\n* Lower Triangular Matrix: In a lower triangular matrix, all elements above the main diagonal (elements that lie on or above the main diagonal) are zeros\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndef up_triangular_matrix(n):\n    \"\"\"\n    Upper Triangular matrix filled with ones and zeroes\n    \"\"\"\n    return np.fromfunction(lambda i, j:  1 * np.less_equal(i , j),\n                           shape=(n, n),\n                           dtype=int)\n```\n:::\n\n\n* Lower Triangular Matrix: In a lower triangular matrix, all elements above the main diagonal (elements that lie on or above the main diagonal) are zeros\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndef lw_triangular_matrix(n):\n    \"\"\"\n    Lower Triangular matrix filled with ones and zeroes\n    \"\"\"\n    return np.fromfunction(lambda i, j:  1 * np.greater_equal(i , j),\n                           shape=(n, n),\n                           dtype=int)\n```\n:::\n\n\n``` {.python .cell-code}\nprint(matrix2latex(up_triangular_matrix(5)))\n```\n$$\n\\left(\n   \\begin{array}{rrrrr}\n      1 & 1 & 1 & 1 & 1 \\\\ \n      0 & 1 & 1 & 1 & 1 \\\\ \n      0 & 0 & 1 & 1 & 1 \\\\ \n      0 & 0 & 0 & 1 & 1 \\\\ \n      0 & 0 & 0 & 0 & 1 \\\\ \n   \\end{array}\n\\right)\n$$\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}